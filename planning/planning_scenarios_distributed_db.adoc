=== Container Interconnection: Distributed Database Server

Introduce the basic environment and began to foreshadow the perceieved complications

==== Database server

By their very nature, distributed application components need to communicate with one another.  
Container technologies encourage developers to make these interconnection points explicit and 
provide a number of mechanisms to coordinate or otherwise enable communication between containers.

Consider the database example in the previous section.  Once we have established persistent 
storage for the database server, we also need to consider how database clients will connect to it.

(Diagram placeholder - Block for running container, inset for listening port on top of container 
block, distinct block outside of container showing shared/mapped directories for UNIX sockets.)

==== Single node application

Simple non-distributed applications may assume that a database is co-located on the same server 
and use an established port number, or UNIX domain socket path, as their default access mechanism.  
Some container coordination frameworks, such as Kubernetes, attempt to simplify this use case for 
containers co-located on a single node by sharing the network port space between node-local containers.

(Diagram placeholder, Kube network model, where PID spaces are distinct but network space is 
shared, allowing a DB client to simply connect to localhost:PORT)

==== Single node application

True multi-node distributed applications may host the database as a distinct node in which case 
communication must occur via the network.  Clients that wish to use the database must be made 
aware of its location, either via explicit configuration or a service discovery mechanism.

(diagram placeholder)

==== Container environment

Once an interconnection mechanism has been established you, as a container developer, must ensure 
that your service containers are properly configured to allow access to these connections.

For connections between containers on a single node, shared filesystem locations, either for domain 
sockets or actual filesystem content, must be set up at the time the containers are launched.  
Docker, for example, allow mapping a host directory to a container directory by adding the following 
argument to the run command:

-v <host_directory>:<container_directory>

In our DB server example, assuming the database maintains a listening UNIX domain socket in 
"/var/run/postgres" we could launch both our server and client with the following argument included:

-v /var/run/postgres:/var/run/postgres

This will ensure that both the server and client see the same directory content, exported from the host, 
allowing the client to connect using the expected/default location.

For network connections, Docker provides a simple directive in the Dockerfile to expose a port from the 
running container.  For example, to create a Postgres DB server container that listents on the default 
Postgres port, you would add the following line:

EXPOSE 5432

